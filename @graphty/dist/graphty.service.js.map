{"version":3,"file":"graphty.service.js","sourceRoot":"","sources":["../../src/graphty.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { GqlQueryInterface, GQLQProducerInterface } from './graphty.interface';\n\n@Injectable()\nexport class GraphtyService {\n\n  constructor() { }\n\n  /**\n   * Set the head of the query by setting name of the function and it's parameters.\n   * \n   * @param {string} funName\n   * @param {object} args \n   * \n   * @returns {string}\n   */\n  public setFuntion(funName: string, args: any = null): string {\n    let funArguments = funName, variables: Array<string> = [];\n    if (typeof args != 'object') this.throError('Invalid argument! one of the arguments must be type of object');\n    if (args) {\n      for (let key in args) {\n        variables.push(key + ':' +(typeof(args[key]) == 'string' ? ('\"' + args[key].replace('\"', '\\\\\"') + '\"') : args[key]));\n      }\n      funArguments += '(' + variables.join(',') + ')';\n    }\n    return funArguments;\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query.\n   * \n   * @param {Array<string>} funBody\n   * \n   * @returns {string}\n   **/\n  public setFunBody(funBody: Array<string | any>): string {\n    if (!Array.isArray(funBody)) this.throError('body of the query should be type of array');\n    let gqlBody: Array<string> = [];\n    for(let key in funBody) {\n      if(typeof(funBody[key]) == 'string') {\n        gqlBody.push(funBody[key]);\n      } else if (typeof(funBody[key]) == 'object' && funBody[key].hasOwnProperty('query')) {\n        gqlBody.push(funBody[key]['query'].slice(funBody[key]['query'].indexOf(\"{\")+1, funBody[key]['query'].lastIndexOf(\"}\") ));\n      } else {\n        this.throError('Invalid parameter in body! the query body should be only type of string');\n      }\n    }\n    return gqlBody.join(',');\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query.\n   * \n   * @param {Array<string>} funBody\n   * \n   * @returns {string}\n   **/\n  public combineQuery(combineQuery: Array<GqlQueryInterface> = [], typeOfQuery: string | null = null): Array<string> {\n    let numOfMutations: number = 0, numOfQueries: number = 0, len: number = combineQuery.length\n    for(let i=0; i<len; i++) {\n        combineQuery[i].query.indexOf('mutation') > -1 ? numOfMutations++ : numOfQueries++;\n    }\n    if(len !=  numOfQueries && len !=  numOfMutations) this.throError('Invalid type of combined queries! All combined queries should call from the same method. Either \"stangnation\" or \"mutation\".');\n    return [combineQuery.map(\n      q=>q.query.slice(q.query.indexOf(\"{\")+1, q.query.lastIndexOf(\"}\"))\n    ).join(','), numOfQueries > numOfMutations ? '': 'mutation'];\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The return query is type of root query and not mutation query.\n   * \n   * @param {Array<string>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public stagnation(graphStruct: GQLQProducerInterface): GqlQueryInterface {\n    let query = '{' +\n      this.setFuntion(graphStruct.fun.name, graphStruct.fun.args) + '{' + \n      this.setFunBody(graphStruct.ret as Array<string | any>) + '}}';\n    return {query};\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The returned query is type of mutation query.\n   * \n   * @param {Array<string | any>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public mutation(graphStruct: GQLQProducerInterface): GqlQueryInterface {\n    let query = 'mutation{' +\n      this.setFuntion(graphStruct.fun.name, graphStruct.fun.args) + '{' + \n      this.setFunBody(graphStruct.ret as Array<string | any>) + '}}';\n    return {query};\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The returned query is type of mutation query.\n   * \n   * @param {Array<string | any>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public combine(ArrGraphStruct: Array<GqlQueryInterface>): GqlQueryInterface {\n    let query: string = '', cqr: Array<string> = [];\n    if (typeof(ArrGraphStruct) == 'object' && Array.isArray(ArrGraphStruct)) {\n      cqr = this.combineQuery(ArrGraphStruct as Array<GqlQueryInterface>);\n    }\n    query = cqr[1] + '{' + cqr[0] +  '}';\n    return {query};\n  }\n\n  /**\n   * Pop error if exists.\n   * \n   * @param {string} msg\n   * \n   * @returns {GqlQuery}\n   **/\n  public throError(msg: string) {\n    throw new Error(msg);\n  }\n\n}"]}