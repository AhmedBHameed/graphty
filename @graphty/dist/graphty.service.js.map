{"version":3,"file":"graphty.service.js","sourceRoot":"","sources":["../../src/graphty.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { GqlQueryInterface, GQLQProducerInterface } from './graphty.interface';\n\n@Injectable()\nexport class GraphtyService {\n\n  constructor() { }\n\n  /**\n   * Set the head of the query by setting name of the function and it's parameters.\n   * \n   * @param {string} funName\n   * @param {object} args \n   * \n   * @returns {string}\n   */\n  public setFuntion(funName: string, args: any = null): string {\n    let funArguments = funName, variables: Array<string> = [];\n    if (typeof args != 'object') this.throError('Invalid argument! one of the arguments must be type of object');\n    if (args) {\n      for (let key in args) {\n        variables.push(key + ':' +(typeof(args[key]) == 'string' ? ('\"' + args[key] + '\"') : args[key]));\n      }\n      funArguments += '(' + variables.join(',') + ')';\n    }\n    return funArguments;\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query.\n   * \n   * @param {Array<string>} funBody\n   * \n   * @returns {string}\n   **/\n  public setFunBody(funBody: Array<string>): string {\n    if (!Array.isArray(funBody)) this.throError('body of the query should be type of array');\n    let gqlBody: Array<string> = [];\n    for(let key in funBody) {\n      if(typeof(funBody[key]) == 'string') {\n        gqlBody.push(funBody[key]);\n      } else {\n        this.throError('Invalid parameter in body! the query body should be only type of string');\n      }\n    }\n    return gqlBody.join(',');\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query.\n   * \n   * @param {Array<string>} funBody\n   * \n   * @returns {string}\n   **/\n  public combineQuery(combineQuery: Array<GqlQueryInterface> = [], typeOfQuery: string | null = null): string {\n    let numOfMutations: number = 0, numOfQueries: number = 0, len: number = combineQuery.length\n    for(let i=0; i<len; i++) {\n        combineQuery[i].query.indexOf('mutation') > -1 ? numOfMutations++ : numOfQueries++;\n    }\n    if(typeOfQuery) {\n      if(len !=  numOfMutations) this.throError('Invalid type of combined queries! Queries should have the same type as \"mutation\" since it is called from \"mutation\" method.');\n    } else {\n      if(len !=  numOfQueries) this.throError('Invalid type of combined queries! Queries should have the same type as \"root query\" since it is called from \"stagnation\" method.');\n    }\n    return ',' + combineQuery.map(\n      q=>q.query.slice(q.query.indexOf(\"{\")+1, q.query.lastIndexOf(\"}\"))\n    ).join(',');\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The return query is type of root query and not mutation query.\n   * \n   * @param {Array<string>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public stagnation(graphStruct: GQLQProducerInterface): GqlQueryInterface {\n    let query = '{' +\n      this.setFuntion(graphStruct.fun.name, graphStruct.fun.args) + '{' + \n      this.setFunBody(graphStruct.ret as Array<string>) + '}' +\n      (graphStruct.combine ? \n        this.combineQuery(graphStruct.combine as Array<GqlQueryInterface>) : '') + \n    '}';\n    return {query};\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The returned query is type of mutation query.\n   * \n   * @param {Array<string | any>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public mutation(graphStruct: GQLQProducerInterface): GqlQueryInterface {\n    let query = 'mutation{' +\n      this.setFuntion(graphStruct.fun.name, graphStruct.fun.args) + '{' + \n      this.setFunBody(graphStruct.ret as Array<string>) + '}' + \n      (graphStruct.combine ? \n        this.combineQuery(graphStruct.combine as Array<GqlQueryInterface>) : '') +\n      '}';\n    return {query};\n  }\n\n  /**\n   * Pop error if exists.\n   * \n   * @param {string} msg\n   * \n   * @returns {GqlQuery}\n   **/\n  public throError(msg: string) {\n    throw new Error(msg);\n  }\n\n}"]}