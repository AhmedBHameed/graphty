{"version":3,"file":"graphty.service.js","sourceRoot":"","sources":["../../src/graphty.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { GqlQueryInterface, GQLQProducerInterface } from './graphty.interface';\n\n@Injectable()\nexport class GraphtyService {\n\n  constructor() { }\n\n  /**\n   * Set the head of the query by setting name of the function and it's parameters.\n   * \n   * @param {string} funName\n   * @param {object} args \n   * \n   * @returns {string}\n   */\n  public setFuntion(funName: string, args: any = null): string {\n    let funArguments = funName, variables: Array<string> = [];\n    if (typeof args != 'object') this.throError('Invalid argument! one of the arguments must be type of object');\n    if (args) {\n      for (let key in args) {\n        variables.push(key + ':' +(typeof(args[key]) == 'string' ? ('\"' + args[key] + '\"') : args[key]));\n      }\n      funArguments += '(' + variables.join(',') + ')';\n    }\n    return funArguments;\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query.\n   * \n   * @param {Array<string | any>} funBody\n   * \n   * @returns {string}\n   **/\n  public setFunBody(funBody: Array<string | any>): string {\n    if (!Array.isArray(funBody)) this.throError('body of the query should be type of array');\n    let gqlBody: Array<string> = [];\n    for(let key in funBody) {\n      if(typeof(funBody[key]) == 'string') {\n        gqlBody.push(funBody[key]);\n      } else if (typeof(funBody[key]) == 'object' && funBody[key].hasOwnProperty('query')) {\n        gqlBody.push(funBody[key]['query'].slice(funBody[key]['query'].indexOf(\"{\")+1, funBody[key]['query'].lastIndexOf(\"}\") ));\n      } else {\n        this.throError('Invalid parameter in body! the query body should be only type of string');\n      }\n    }\n    return gqlBody.join(',');\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The return query is type of root query and not mutation query.\n   * \n   * @param {Array<string | any>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public stagnation(graphStruct: GQLQProducerInterface): GqlQueryInterface {\n    let query = \n      '{' + this.setFuntion(graphStruct.fun.name, graphStruct.fun.args) + '{' + \n      this.setFunBody(graphStruct.ret as Array<string | any>) + '}}';\n    return {query};\n  }\n\n  /**\n   * Set the body of the query by setting required keys as responded fields. It can be another function.\n   * as nested query. The returned query is type of mutation query.\n   * \n   * @param {Array<string | any>} funBody\n   * \n   * @returns {GqlQuery}\n   **/\n  public mutation(graphStruct: GQLQProducerInterface): GqlQueryInterface {\n    let query = \n      'mutation{' + this.setFuntion(graphStruct.fun.name, graphStruct.fun.args) + '{' + \n      this.setFunBody(graphStruct.ret as Array<string | any>) + '}}';\n    return {query};\n  }\n\n  /**\n   * Pop error if exists.\n   * \n   * @param {string} msg\n   * \n   * @returns {GqlQuery}\n   **/\n  public throError(msg: string) {\n    throw new Error(msg);\n  }\n\n}"]}